{"version":3,"file":"i18n_html_parser.js","sourceRoot":"","sources":["../../../../../../modules/@angular/compiler/src/i18n/i18n_html_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Parser as ExpressionParser} from '../expression_parser/parser';\nimport {ListWrapper, StringMapWrapper} from '../facade/collection';\nimport {BaseException} from '../facade/exceptions';\nimport {NumberWrapper, RegExpWrapper, isPresent} from '../facade/lang';\nimport {HtmlAst, HtmlAstVisitor, HtmlAttrAst, HtmlCommentAst, HtmlElementAst, HtmlExpansionAst, HtmlExpansionCaseAst, HtmlTextAst, htmlVisitAll} from '../html_ast';\nimport {HtmlParseTreeResult, HtmlParser} from '../html_parser';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../interpolation_config';\nimport {ParseError, ParseSourceSpan} from '../parse_util';\nimport {Message, id} from './message';\nimport {I18N_ATTR, I18N_ATTR_PREFIX, I18nError, Part, dedupePhName, extractPhNameFromInterpolation, messageFromAttribute, messageFromI18nAttribute, partition} from './shared';\n\nconst _PLACEHOLDER_ELEMENT = 'ph';\nconst _NAME_ATTR = 'name';\nconst _PLACEHOLDER_EXPANDED_REGEXP = /<ph\\s+name=\"(\\w+)\"><\\/ph>/gi;\n\n/**\n * Creates an i18n-ed version of the parsed template.\n *\n * Algorithm:\n *\n * See `message_extractor.ts` for details on the partitioning algorithm.\n *\n * This is how the merging works:\n *\n * 1. Use the stringify function to get the message id. Look up the message in the map.\n * 2. Get the translated message. At this point we have two trees: the original tree\n * and the translated tree, where all the elements are replaced with placeholders.\n * 3. Use the original tree to create a mapping Index:number -> HtmlAst.\n * 4. Walk the translated tree.\n * 5. If we encounter a placeholder element, get its name property.\n * 6. Get the type and the index of the node using the name property.\n * 7. If the type is 'e', which means element, then:\n *     - translate the attributes of the original element\n *     - recurse to merge the children\n *     - create a new element using the original element name, original position,\n *     and translated children and attributes\n * 8. If the type if 't', which means text, then:\n *     - get the list of expressions from the original node.\n *     - get the string version of the interpolation subtree\n *     - find all the placeholders in the translated message, and replace them with the\n *     corresponding original expressions\n */\nexport class I18nHtmlParser implements HtmlParser {\n  private _errors: ParseError[];\n  private _interpolationConfig: InterpolationConfig;\n\n  constructor(\n      private _htmlParser: HtmlParser, public _expressionParser: ExpressionParser,\n      private _messagesContent: string, private _messages: {[key: string]: HtmlAst[]},\n      private _implicitTags: string[], private _implicitAttrs: {[k: string]: string[]}) {}\n\n  parse(\n      sourceContent: string, sourceUrl: string, parseExpansionForms: boolean = false,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG):\n      HtmlParseTreeResult {\n    this._errors = [];\n    this._interpolationConfig = interpolationConfig;\n\n    let res = this._htmlParser.parse(sourceContent, sourceUrl, true, interpolationConfig);\n\n    if (res.errors.length > 0) {\n      return res;\n    }\n\n    const nodes = this._recurse(res.rootNodes);\n\n    return this._errors.length > 0 ? new HtmlParseTreeResult([], this._errors) :\n                                     new HtmlParseTreeResult(nodes, []);\n  }\n\n  // Merge the translation recursively\n  private _processI18nPart(part: Part): HtmlAst[] {\n    try {\n      return part.hasI18n ? this._mergeI18Part(part) : this._recurseIntoI18nPart(part);\n    } catch (e) {\n      if (e instanceof I18nError) {\n        this._errors.push(e);\n        return [];\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  private _recurseIntoI18nPart(p: Part): HtmlAst[] {\n    // we found an element without an i18n attribute\n    // we need to recurse in case its children may have i18n set\n    // we also need to translate its attributes\n    if (isPresent(p.rootElement)) {\n      const root = p.rootElement;\n      const children = this._recurse(p.children);\n      const attrs = this._i18nAttributes(root);\n      return [new HtmlElementAst(\n          root.name, attrs, children, root.sourceSpan, root.startSourceSpan, root.endSourceSpan)];\n    }\n\n    if (isPresent(p.rootTextNode)) {\n      // a text node without i18n or interpolation, nothing to do\n      return [p.rootTextNode];\n    }\n\n    return this._recurse(p.children);\n  }\n\n  private _recurse(nodes: HtmlAst[]): HtmlAst[] {\n    let parts = partition(nodes, this._errors, this._implicitTags);\n    return ListWrapper.flatten(parts.map(p => this._processI18nPart(p)));\n  }\n\n  // Look for the translated message and merge it back to the tree\n  private _mergeI18Part(part: Part): HtmlAst[] {\n    let message = part.createMessage(this._expressionParser, this._interpolationConfig);\n    let messageId = id(message);\n\n    if (!StringMapWrapper.contains(this._messages, messageId)) {\n      throw new I18nError(\n          part.sourceSpan,\n          `Cannot find message for id '${messageId}', content '${message.content}'.`);\n    }\n\n    const translation = this._messages[messageId];\n    return this._mergeTrees(part, translation);\n  }\n\n\n  private _mergeTrees(part: Part, translation: HtmlAst[]): HtmlAst[] {\n    if (isPresent(part.rootTextNode)) {\n      // this should never happen with a part. Parts that have root text node should not be merged.\n      throw new BaseException('should not be reached');\n    }\n\n    const visitor = new _NodeMappingVisitor();\n    htmlVisitAll(visitor, part.children);\n\n    // merge the translated tree with the original tree.\n    // we do it by preserving the source code position of the original tree\n    const translatedAst = this._expandPlaceholders(translation, visitor.mapping);\n\n    // if the root element is present, we need to create a new root element with its attributes\n    // translated\n    if (part.rootElement) {\n      const root = part.rootElement;\n      const attrs = this._i18nAttributes(root);\n      return [new HtmlElementAst(\n          root.name, attrs, translatedAst, root.sourceSpan, root.startSourceSpan,\n          root.endSourceSpan)];\n    }\n\n    return translatedAst;\n  }\n\n  /**\n   * The translation AST is composed on text nodes and placeholder elements\n   */\n  private _expandPlaceholders(translation: HtmlAst[], mapping: HtmlAst[]): HtmlAst[] {\n    return translation.map(node => {\n      if (node instanceof HtmlElementAst) {\n        // This node is a placeholder, replace with the original content\n        return this._expandPlaceholdersInNode(node, mapping);\n      }\n\n      if (node instanceof HtmlTextAst) {\n        return node;\n      }\n\n      throw new BaseException('should not be reached');\n    });\n  }\n\n  private _expandPlaceholdersInNode(node: HtmlElementAst, mapping: HtmlAst[]): HtmlAst {\n    let name = this._getName(node);\n    let index = NumberWrapper.parseInt(name.substring(1), 10);\n    let originalNode = mapping[index];\n\n    if (originalNode instanceof HtmlTextAst) {\n      return this._mergeTextInterpolation(node, originalNode);\n    }\n\n    if (originalNode instanceof HtmlElementAst) {\n      return this._mergeElement(node, originalNode, mapping);\n    }\n\n    throw new BaseException('should not be reached');\n  }\n\n  // Extract the value of a <ph> name attribute\n  private _getName(node: HtmlElementAst): string {\n    if (node.name != _PLACEHOLDER_ELEMENT) {\n      throw new I18nError(\n          node.sourceSpan,\n          `Unexpected tag \"${node.name}\". Only \"${_PLACEHOLDER_ELEMENT}\" tags are allowed.`);\n    }\n\n    const nameAttr = node.attrs.find(a => a.name == _NAME_ATTR);\n\n    if (nameAttr) {\n      return nameAttr.value;\n    }\n\n    throw new I18nError(node.sourceSpan, `Missing \"${_NAME_ATTR}\" attribute.`);\n  }\n\n  private _mergeTextInterpolation(node: HtmlElementAst, originalNode: HtmlTextAst): HtmlTextAst {\n    const split = this._expressionParser.splitInterpolation(\n        originalNode.value, originalNode.sourceSpan.toString(), this._interpolationConfig);\n\n    const exps = split ? split.expressions : [];\n\n    const messageSubstring = this._messagesContent.substring(\n        node.startSourceSpan.end.offset, node.endSourceSpan.start.offset);\n\n    let translated = this._replacePlaceholdersWithInterpolations(\n        messageSubstring, exps, originalNode.sourceSpan);\n\n    return new HtmlTextAst(translated, originalNode.sourceSpan);\n  }\n\n  private _mergeElement(node: HtmlElementAst, originalNode: HtmlElementAst, mapping: HtmlAst[]):\n      HtmlElementAst {\n    const children = this._expandPlaceholders(node.children, mapping);\n\n    return new HtmlElementAst(\n        originalNode.name, this._i18nAttributes(originalNode), children, originalNode.sourceSpan,\n        originalNode.startSourceSpan, originalNode.endSourceSpan);\n  }\n\n  private _i18nAttributes(el: HtmlElementAst): HtmlAttrAst[] {\n    let res: HtmlAttrAst[] = [];\n    let implicitAttrs: string[] =\n        isPresent(this._implicitAttrs[el.name]) ? this._implicitAttrs[el.name] : [];\n\n    el.attrs.forEach(attr => {\n      if (attr.name.startsWith(I18N_ATTR_PREFIX) || attr.name == I18N_ATTR) return;\n\n      let message: Message;\n\n      let i18nAttr = el.attrs.find(a => a.name == `${I18N_ATTR_PREFIX}${attr.name}`);\n\n      if (!i18nAttr) {\n        if (implicitAttrs.indexOf(attr.name) == -1) {\n          res.push(attr);\n          return;\n        }\n        message = messageFromAttribute(this._expressionParser, this._interpolationConfig, attr);\n      } else {\n        message = messageFromI18nAttribute(\n            this._expressionParser, this._interpolationConfig, el, i18nAttr);\n      }\n\n      let messageId = id(message);\n\n      if (StringMapWrapper.contains(this._messages, messageId)) {\n        const updatedMessage = this._replaceInterpolationInAttr(attr, this._messages[messageId]);\n        res.push(new HtmlAttrAst(attr.name, updatedMessage, attr.sourceSpan));\n\n      } else {\n        throw new I18nError(\n            attr.sourceSpan,\n            `Cannot find message for id '${messageId}', content '${message.content}'.`);\n      }\n    });\n\n    return res;\n  }\n\n  private _replaceInterpolationInAttr(attr: HtmlAttrAst, msg: HtmlAst[]): string {\n    const split = this._expressionParser.splitInterpolation(\n        attr.value, attr.sourceSpan.toString(), this._interpolationConfig);\n    const exps = isPresent(split) ? split.expressions : [];\n\n    const first = msg[0];\n    const last = msg[msg.length - 1];\n\n    const start = first.sourceSpan.start.offset;\n    const end =\n        last instanceof HtmlElementAst ? last.endSourceSpan.end.offset : last.sourceSpan.end.offset;\n    const messageSubstring = this._messagesContent.substring(start, end);\n\n    return this._replacePlaceholdersWithInterpolations(messageSubstring, exps, attr.sourceSpan);\n  };\n\n  private _replacePlaceholdersWithInterpolations(\n      message: string, exps: string[], sourceSpan: ParseSourceSpan): string {\n    const expMap = this._buildExprMap(exps);\n\n    return message.replace(\n        _PLACEHOLDER_EXPANDED_REGEXP,\n        (_: string, name: string) => this._convertIntoExpression(name, expMap, sourceSpan));\n  }\n\n  private _buildExprMap(exps: string[]): Map<string, string> {\n    const expMap = new Map<string, string>();\n    const usedNames = new Map<string, number>();\n\n    for (let i = 0; i < exps.length; i++) {\n      const phName = extractPhNameFromInterpolation(exps[i], i);\n      expMap.set(dedupePhName(usedNames, phName), exps[i]);\n    }\n\n    return expMap;\n  }\n\n  private _convertIntoExpression(\n      name: string, expMap: Map<string, string>, sourceSpan: ParseSourceSpan) {\n    if (expMap.has(name)) {\n      return `${this._interpolationConfig.start}${expMap.get(name)}${this._interpolationConfig.end}`;\n    }\n\n    throw new I18nError(sourceSpan, `Invalid interpolation name '${name}'`);\n  }\n}\n\n// Creates a list of elements and text nodes in the AST\n// The indexes match the placeholders indexes\nclass _NodeMappingVisitor implements HtmlAstVisitor {\n  mapping: HtmlAst[] = [];\n\n  visitElement(ast: HtmlElementAst, context: any): any {\n    this.mapping.push(ast);\n    htmlVisitAll(this, ast.children);\n  }\n\n  visitText(ast: HtmlTextAst, context: any): any { this.mapping.push(ast); }\n\n  visitAttr(ast: HtmlAttrAst, context: any): any {}\n  visitExpansion(ast: HtmlExpansionAst, context: any): any {}\n  visitExpansionCase(ast: HtmlExpansionCaseAst, context: any): any {}\n  visitComment(ast: HtmlCommentAst, context: any): any {}\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}